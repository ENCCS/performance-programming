<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms &mdash; Performance Engineering  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_lesson.css" />
      <link rel="stylesheet" type="text/css" href="../_static/term_role_formatting.css" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_rtd_theme_ext_color_contrast.css" />
      <link rel="stylesheet" type="text/css" href="../_static/overrides.css" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Compilers" href="../compilers/" />
    <link rel="prev" title="Setup" href="../setup/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            Performance Engineering
              <img src="../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Before The Lesson</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The lesson</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#complexity">Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quadratic-algorithms-and-hash-tables">Quadratic algorithms and hash tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#divide-and-conquer-sorting-and-randomness">Divide and conquer, sorting and randomness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-algorithms">Sparse algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-reads">Further reads</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../compilers/">Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture/">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tuning/">Tuning</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">Performance Engineering</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Algorithms</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/content/blob/main/content/algorithms.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="algorithms">
<h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading"></a></h1>
<p>The first step towards writing efficient code is to start from a good algorithm. It is also where
the most dramatic performance improvements can be found.</p>
<p>Sometimes good algorithms are available in libraries and the only thing one needs to do is to call them. But when
you write code to solve a new problem, or an old problem in a new way, you are on your own.</p>
<p>Hence this chapter of the lesson is about algorithms, or rather about algorithmic patterns.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>We will be measuring execution time in this and later parts. There are a few pitfalls
that one should be aware of.</p>
<ul>
<li><p>Run your measurements on an unloaded system. Even if you have a multicore, there
are many resources that are shared between the cores, including the memory interface.
One perhaps surprising example is the power envelope; often clock frequency can be
raised if only one core is active.</p>
<p>If you are following this workshop online, you are probably running a
videoconferencing system in the background. That is very likely to affect
any measurements you make.</p>
</li>
<li><p>Do not measure too short times. There is always some overhead. There is also the case that
while the processor is not too busy, it runs with a reduced clock frequency,
and it may take a little time before the clock frequency is increased.
A good idea is to want to run for at least a quarter of a second or so.</p></li>
<li><p>Do not make a longer time to measure by using a loop in a shell script, or
similar. Your program will be started many times, and that overhead may become
a large part of the time you measure.</p></li>
</ul>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can find the files used in this section
<a class="reference external" href="https://github.com/ENCCS/performance-programming/blob/main/algorithm-files.zip">here</a> as
a zip archive. Follow the link, click on “View raw” and you will get it downloaded.
Move or copy it to where you want it, then unpack it like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>unzip<span class="w"> </span>algorithm-files.zip
</pre></div>
</div>
</div>
<section id="complexity">
<h2>Complexity<a class="headerlink" href="#complexity" title="Permalink to this heading"></a></h2>
<p>Algorithms are often categorized by their <em>complexity</em>, meaning their execution time as a function of
the size of the input. Since the actual running time varies between systems, the execution time we use
in this context is the number of steps that an idealized (model of a) computer called a Random Access Machine,
or <em>RAM</em> (do not confound with <em>Random Access Memory</em>), would need. Input sizes are measured in different ways for different algorithms.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>For a naive
simulation of gravitational attraction between a large number of stars, the size of the problem is typically
the number of stars. Since every star is attracted by every other star, the work for a single time
step of the simulation is proportional to the square of the number of stars.</p>
<p>As an alternative, one could imagine doing the force calculation by dividing space into a number of fixed
size cells and compute the force on each star by considering the mass of stars in each cell. The cost of
doing that for one star would be proportional to the number of cells, thus the size and the granularity
of the simulated space becomes part of the size of the problem for this alternative approach.</p>
</div>
<p>Actual computers differ from the RAM and from each other in many details, and these have important
consequences for performance, as we will see later. However, almost always the difference
can be expressed as a constant multiplicative factor. That is, one machine is about <span class="math notranslate nohighlight">\(X\)</span> times faster than
another independent of the size of the input.</p>
<p>Thus, when we discuss the complexity of an algorithm, we are not interested in absolute performance
but rather in how the execution time changes when the size of the input changes. This is typically expressed using
the “big O” notation; we write that the naive gravity simulation algorithm above is <span class="math notranslate nohighlight">\(O(n^2)\)</span> to mean that
for large enough <span class="math notranslate nohighlight">\(n\)</span> there is a constant <span class="math notranslate nohighlight">\(c\)</span> such that the algorithm uses at most <span class="math notranslate nohighlight">\(cn^2\)</span> steps
on a RAM to solve a problem of size <span class="math notranslate nohighlight">\(n\)</span>. The “large enough” provisio captures the fact that we are interested
in what happens “in the limit”. Technically, it for instance allows us to amortize
any fixed cost initialization over the entire computation.</p>
</section>
<section id="quadratic-algorithms-and-hash-tables">
<h2>Quadratic algorithms and hash tables<a class="headerlink" href="#quadratic-algorithms-and-hash-tables" title="Permalink to this heading"></a></h2>
<p>Consider the problem of determining if the elements of an array of interǵers are all unique. Here is a simple
version that compares all pairs of elements:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">unique1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Complexity is quadratic (<span class="math notranslate nohighlight">\(n^2\)</span>) due to the nested loops. Some of the computation is clearly redundant,
each pair (x,y) of distict indices is checked twice, once when <cite>i==x</cite> and <cite>j==y</cite> and once when <cite>i==y</cite>
and <cite>j==x</cite>. So the first improvement is to remove this simple redundancy:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">unique2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we insist that <cite>i&lt;j</cite> at all times so we check each (x,y) pair only once and also at the same time
we avoid the test ensuring that <cite>i != j</cite>. Can we do better? Yes, by sorting the array first. Sorting
can be accomplished in time <span class="math notranslate nohighlight">\(O(n \log(n))\)</span> which is much faster than <span class="math notranslate nohighlight">\(O(n^2)\)</span>. Having sorted the
array, equal elements are now adjacent.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">unique3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we helped ourselves to a function <code class="docutils literal notranslate"><span class="pre">sort()</span></code> that sorts an array of <code class="docutils literal notranslate"><span class="pre">int</span></code>. There are interesting lessons
to learn from implementing that function, and we will return to these later.</p>
<p>What is the complexity of <code class="docutils literal notranslate"><span class="pre">unique3()</span></code>? The function first sorts the array, then traverses it linearly in a single
pass, a process that is clearly <span class="math notranslate nohighlight">\(O(n)\)</span>. If the algorithm used by <code class="docutils literal notranslate"><span class="pre">sort()</span></code> is <span class="math notranslate nohighlight">\(O(n\log(n))\)</span>, this means
that the entire algorithm is <span class="math notranslate nohighlight">\(O(n\log(n))\)</span> since this is asymptotically greater. There is no constant <span class="math notranslate nohighlight">\(c\)</span>
such that <span class="math notranslate nohighlight">\(cn &gt; n\log(n)\)</span> for large <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Is there a way to solve this problem even faster? There is at least one variation that is likely to be faster in many
cases, and that involves using a <em>hash table</em>. This is a data structure that can be used to implement a set with fast
insert, delete, and membership test (in general, a hash table can implement a finite map from a set of <em>keys</em> to a set of
arbitrary values). If the keys are small enough integers, we do not need a hash table and can just use an array.</p>
<p>The new version iterates over the integers in the array one by one, looks up each one in the hash table and inserts it if
it was not there.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">unique4</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ht_t</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">member</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">insert</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">delete_hash_table</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A hash table is implemented as an array that is indexed using a value computed from the key using a <em>hash function</em>.
The hash value must be a valid index into the table, so if the size of the table is
<span class="math notranslate nohighlight">\(s\)</span> then the hash value <span class="math notranslate nohighlight">\(v\)</span> must satisfy <span class="math notranslate nohighlight">\(0 \leq v &lt; s\)</span>.</p>
<p>Each entry in the hash table collects those keys that are mapped to that entry’s index by the hash function.
When checking if a particular key <em>k</em> is present, all of the keys in the hash table entry must be compared
to <em>k</em>. Clearly, performance will be best if each table entry contains at most one key. In that case, there will only
be one comparison computed for each access.</p>
<p>Whether a particular hash function is good or not depends on the distribution of keys that we want to keep in the
hash table at the same time, which is application dependent.</p>
<div class="admonition-uses-of-hash-tables admonition">
<p class="admonition-title">Uses of hash tables</p>
<blockquote>
<div><p>Hash tables are useful in several high performance computing domains:</p>
<dl class="simple">
<dt>Genomic Data Processing</dt><dd><p>In bioinformatics, hash tables are often used to store and quickly retrieve genomic data. For example,
they can be used to store k-mers (subsequences of length k) in DNA sequence analysis or genome assembly tasks.</p>
</dd>
<dt>Graph Analytics</dt><dd><p>In graph analytics, hash tables can be used to represent sparse adjacency matrices or edge lists, allowing
for efficient access and manipulation of graph data.</p>
</dd>
<dt>Particle Simulations</dt><dd><p>In particle simulations (like molecular dynamics), hash tables can be used to efficiently keep track of
particles in a given spatial region. This is particularly useful when particles only interact with very
nearby particles. Then space can be divided into a grid of cells. If most cells are empty, a hash table
where the key is the cell coordinates can be a good representation.</p>
</dd>
</dl>
</div></blockquote>
</div>
</section>
<section id="divide-and-conquer-sorting-and-randomness">
<h2>Divide and conquer, sorting and randomness<a class="headerlink" href="#divide-and-conquer-sorting-and-randomness" title="Permalink to this heading"></a></h2>
<p>Above, we used sorting to improve the performance of the <code class="docutils literal notranslate"><span class="pre">unique</span></code> function. Here we
will take a look at how a sort function can be implemented. This will illustrate
some additional points about algorithm design.</p>
<p>Below is an old and famous sorting algorithm known as Quicksort. It is an example of
a recursive <em>divide and conquer</em> algorithm. The idea of this class of algorithm is to
to divide a problem into smaller sub problems, solve the sub problems, and combine
the solutions. For this scheme to work, small enough sub problems must be solved by
another method or be trivial. For the case of sorting, an array with less than two
elements is trivially sorted.</p>
<p>Thus, in a divide and conquer algorithm, the meat is in dividing the original
problem into two (or sometimes more) sub problems and then combining the results.
Either of these steps, but not both, can be trivial (well, if both are trivial, you
are <em>very</em> lucky).</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="w">  </span>
<span class="linenos"> 4</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
<span class="linenos"> 7</span><span class="w">  </span>
<span class="linenos"> 8</span><span class="w">  </span><span class="c1">// Put all elements smaller than pivot to the left (lower part)</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="c1">// and all larger elements to the right.</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">      </span><span class="n">left</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">14</span><span class="w">      </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
<span class="linenos">15</span><span class="w">      </span><span class="n">right</span><span class="o">--</span><span class="p">;</span>
<span class="linenos">16</span><span class="w">      </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
<span class="linenos">17</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">18</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">// All elements to the left of &#39;right&#39; are now smaller than </span>
<span class="linenos">21</span><span class="w">  </span><span class="c1">// all elements to the right (above) &#39;right&#39;.</span>
<span class="linenos">22</span><span class="w">  </span>
<span class="linenos">23</span><span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w"> </span><span class="c1">// Sort the smaller elements</span>
<span class="linenos">24</span><span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Sort the larger elements</span>
<span class="linenos">25</span><span class="p">}</span>
</pre></div>
</div>
<p>We can visualize the execution of this algorithm as a call tree where each node
corresponds to one call to <code class="docutils literal notranslate"><span class="pre">quicksort</span></code>. The root is the call in the
<code class="docutils literal notranslate"><span class="pre">main</span></code> function which passes an array with 201 numbers. That array is then
split in a lower and an upper part. Note that the numbers in the figure represent
indices, places in the array, rather than the numbers in it.</p>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="../_images/qs-calltre.png"><img alt="../_images/qs-calltre.png" src="../_images/qs-calltre.png" style="width: 663.5px; height: 304.5px;" /></a>
<figcaption>
<p><span class="caption-text">The call tree of <code class="docutils literal notranslate"><span class="pre">quicksort</span></code></span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>As you can see, the tree is not perfectly balanced; the largest child will
process somewhat more than half of the data of its parent. If the division was
perfect, the depth of the tree would be the base 2 logarithm of the number
of elements in the array to be sorted. Now it will be somewhat larger, but not
more than <span class="math notranslate nohighlight">\(1.4 \log_2(n)\)</span> on average.</p>
<p>As you can see in the figure, each layer of the call tree processes approximately
<span class="math notranslate nohighlight">\(n\)</span> numbers (pivots at upper levels are skipped). Hence the expected
performance is roughly <span class="math notranslate nohighlight">\(1.4n\log_2(n)\)</span>.</p>
<p>But how fast is that in practice?</p>
<div class="admonition-exercise exercise important admonition" id="exercise-0">
<p class="admonition-title">Exercise</p>
<p>Explore the performance of <code class="docutils literal notranslate"><span class="pre">quicksort</span></code>! You can build the program with the
following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-O3<span class="w"> </span>-o<span class="w"> </span>quicksort<span class="w"> </span>quicksort.c<span class="w"> </span>qmain.c
</pre></div>
</div>
<p>This will give you an executable program that you can run as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./quicksort<span class="w"> </span><span class="m">1000</span>
</pre></div>
</div>
<p>The argument tells the main program how many numbers to have in the array to
sort. The numbers will be initialized randomly.</p>
<p>You can get the execution time from the <code class="docutils literal notranslate"><span class="pre">time</span></code> command, as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">time</span><span class="w"> </span>-p<span class="w"> </span>./quicksort<span class="w"> </span><span class="m">1000</span>
</pre></div>
</div>
<p>Try out some different sizes!</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Solution</p>
<p>Here are the results from the Core i7-8550U as well as a linear function
fitted to the smaller sizes (left part of plot).</p>
<img alt="../_images/quicksort-time.png" src="../_images/quicksort-time.png" />
<p>We see that for large <span class="math notranslate nohighlight">\(N\)</span>, <span class="math notranslate nohighlight">\(N \log(N)\)</span> is pretty linear, although
the constant is rather large; 96ns corresponds to some 350 clock cycles. But
that must be amortized over some 30-ish levels in the tree. This gives a cost
of just over 10 cycles per comparison, which, as we will see later, is expected.</p>
</div>
<p>One conclusion we can draw from our study of <code class="docutils literal notranslate"><span class="pre">quicksort</span></code> is that as long as
<span class="math notranslate nohighlight">\(n\)</span> is the size of a data structure, that is related to memory size and not
absolutely fantastically large, <span class="math notranslate nohighlight">\(\log(n)\)</span> is more or less a constant (it will
for instance hardly be larger than 40). Maybe
not a very good constant, but it is not
something that makes the complexity of a program grow without bound.</p>
<p>So far, we have run <code class="docutils literal notranslate"><span class="pre">quicksort</span></code> with randomly generated data, but what if the
data is already sorted?</p>
<div class="admonition-exercise exercise important admonition" id="exercise-1">
<p class="admonition-title">Exercise</p>
<p>Explore the performance of <code class="docutils literal notranslate"><span class="pre">quicksort</span></code> in a sorted input. The
<code class="docutils literal notranslate"><span class="pre">main</span></code> function will initialise the array to be strictly increasing if
you invoke the program like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./quicksort<span class="w"> </span>seq<span class="w"> </span><span class="m">1000</span>
</pre></div>
</div>
<p>Tip: Try smaller sizes first!</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-1">
<p class="admonition-title">Solution</p>
<p>Here is what we get on the Core i7-8550U:</p>
<img alt="../_images/quicksort-seq-time.png" src="../_images/quicksort-seq-time.png" />
<p>This is quite a big difference to the random input case. A quadratic function
fits very well.</p>
</div>
<p>What is happening here is that the pivot chosen always happens to be the largest
value in the range, so in each case one of the recursive calls will get everything
but the pivot wheras the other will get an empty range. Thus the depth becomes linear
rather than logarithmic and the complexity becomes quadratic.</p>
<p>One solution to this problem is to choose the pivot randomly. This means that
instead of running slowly on some input arrays, the algorithm runs slowly on some
random uses. Hence, whatever the input distribution, the algorithm will run
fast on average.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="w">  </span>
<span class="linenos"> 6</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">  </span>
<span class="linenos"> 8</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">];</span>
<span class="linenos">11</span><span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
<span class="linenos">12</span><span class="w">  </span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">// Put all elements smaller than pivot to the left (lower part)</span>
<span class="linenos">14</span><span class="w">  </span><span class="c1">// and all larger elements to the right.</span>
<span class="linenos">15</span><span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">17</span><span class="w">      </span><span class="n">left</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">18</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">19</span><span class="w">      </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
<span class="linenos">20</span><span class="w">      </span><span class="n">right</span><span class="o">--</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">      </span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
<span class="linenos">22</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">23</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">24</span><span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="linenos">25</span><span class="w">  </span><span class="c1">// All elements to the left of &#39;right&#39; are now smaller than </span>
<span class="linenos">26</span><span class="w">  </span><span class="c1">// all elements to the right (above) &#39;right&#39;.</span>
<span class="linenos">27</span><span class="w">  </span>
<span class="linenos">28</span><span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span><span class="w"> </span><span class="c1">// Sort the smaller elements</span>
<span class="linenos">29</span><span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Sort the larger elements</span>
<span class="linenos">30</span><span class="p">}</span>
</pre></div>
</div>
<p>Here we make a random selection unless <code class="docutils literal notranslate"><span class="pre">n</span></code> is so small that it does not matter
(if we would try to get a sort function that was fast in practice, we would probably
go for another algorithm, for instance selection sort, for small <code class="docutils literal notranslate"><span class="pre">n</span></code>).</p>
<div class="admonition-exercise exercise important admonition" id="exercise-2">
<p class="admonition-title">Exercise</p>
<p>Explore the performance of <code class="docutils literal notranslate"><span class="pre">quicksort</span></code> with random pivoting! You can build
the program with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-O3<span class="w"> </span>-o<span class="w"> </span>quicksort<span class="w"> </span>quicksort-rp.c<span class="w"> </span>qmain.c
</pre></div>
</div>
<p>This will give you an executable program that you can run as before:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./quicksort<span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="c1"># Randomly scrambled input</span>
./quicksort<span class="w"> </span>seq<span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="c1"># Ordered input</span>
</pre></div>
</div>
<p>Try out some different sizes, and compare scrambled and ordered input!</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-2">
<p class="admonition-title">Solution</p>
<p>Here are the results from the Core i7-8550U for both scrambeld and ordered input
and with the original (fixed pivot) scrambled input times.</p>
<img alt="../_images/quicksort-rp-time.png" src="../_images/quicksort-rp-time.png" />
<p>We see that with rendom pivots, we are back to an almost linear behaviour.
Interestingly, the case with random pivot and ordered inputs runs almost three
times faster than the unordered input. We will come back to this when we know
more about computer architecture.</p>
<p>We can also see that for unordered input, the random pivot version is somewhat
slower due to the cost of computing the random numbers.</p>
</div>
</section>
<section id="sparse-algorithms">
<h2>Sparse algorithms<a class="headerlink" href="#sparse-algorithms" title="Permalink to this heading"></a></h2>
<p>A typical situation when dealing with vectors or matrices is when one of them
are sparse, meaning that it contains a large fraction of zeroes. An example is the
inner product between two vectors. If calculations are executed through the usual method,
as seen in the code below, a lot of time will be wasted in computing zeroes.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kt">double</span><span class="w"> </span><span class="nf">traditional_ip</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">3</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">   </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="linenos">5</span><span class="p">}</span>
<span class="linenos">6</span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="linenos">7</span><span class="p">}</span>
</pre></div>
</div>
<p>Instead, the classical examples of sparse algorithms come from linear algebra and
teach us to represent such data structures more compactly by taking advantage of
its sparseness, typically, by only representing the non zero elements.
Similarly, when computing the inner product between two vectors, if one of them is sparse,
only the positions where that vector is nonzero need to be considered.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="p">}</span><span class="w"> </span><span class="n">nonzero_t</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="kt">double</span><span class="w"> </span><span class="nf">sparse_ip</span><span class="p">(</span><span class="n">nonzero_t</span><span class="w"> </span><span class="o">*</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_nonzero</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">dv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_nonzero</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dv</span><span class="p">[</span><span class="n">sv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">];</span>
<span class="linenos">10</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">11</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="linenos">12</span><span class="p">}</span>
</pre></div>
</div>
<p>If more than half of the values in <code class="docutils literal notranslate"><span class="pre">sv</span></code> are zero, the sparse representation
will be smaller. Also, the multiplication and addition need only be performed
for the nonzero elements of <code class="docutils literal notranslate"><span class="pre">sv</span></code>.</p>
<p>On the other hand, we have indirect accesses for <code class="docutils literal notranslate"><span class="pre">dv</span></code>; rather than simply walking
through it like we would do in a dense implementation, we make random accesses
to the elements indicated by <code class="docutils literal notranslate"><span class="pre">sv</span></code>. Also, SIMD vectorization becomes more difficult
and less efficient.</p>
<p>So in practice, the trade off may well be at 80-90% zeroes rather than 50%, but
that depends on details of algorithms and hardware.</p>
<div class="admonition-exercise exercise important admonition" id="exercise-3">
<p class="admonition-title">Exercise</p>
<p>The code dotproduct.c includes both the method above as well as a direct method
for calculating dot products. Explore and compare their performance!</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-O3<span class="w"> </span>-o<span class="w"> </span>dotproduct<span class="w"> </span>dotproduct.c
</pre></div>
</div>
<p>To use, you can use the parameters such as vector size, method (sparse, traditional), and degree of sparsity (from 0 to 1).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./dotproduct<span class="w"> </span>--size<span class="w"> </span><span class="m">10000000</span><span class="w"> </span>--method<span class="w"> </span>both<span class="w"> </span>--sparcity<span class="w"> </span><span class="m">0</span>.9
</pre></div>
</div>
<p>The code already displays time measurements, so you do not need to use <code class="docutils literal notranslate"><span class="pre">time</span> <span class="pre">-p</span></code>
before running it. Try variating both the vector size and the amount of sparsity!</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-3">
<p class="admonition-title">Solution</p>
<p>Here are the results from the previous exercise.</p>
<img alt="../_images/sparsity-comparison.png" src="../_images/sparsity-comparison.png" />
<p>The execution keeps roughly between 2 to 3 times faster in the sparse method as the length  of the array increases.</p>
<p>On the right, for lower sparsity,  the traditional method of calculating inner product
ends up being faster than the sparse method. This changes more drasticly at around 50 to 60%,
and having a even more faster execution time when the sparsity is at over 90% (i.e., 95%, 99%, 99.9%).
In the last two cases, the execution time can be up to 45 times faster in the sparse method.</p>
</div>
</section>
<section id="further-reads">
<h2>Further reads<a class="headerlink" href="#further-reads" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Thomas H. Cormen, Charles E. Leiserson and others. “Introduction to Algorithms”, Fourth Edition. The MIT Press. 2022.</p></li>
<li><p>Phillip N. Klein. “Coding the Matrix: Linear Algebra Through Applications to Computer Science”, 2013 Edition. Newtonian Press. 2013.</p></li>
<li><p>Harold Abelson, Gerald Jay Sussman and others. “Structure and Interpretation of Computer Programs”, 2nd Edition. The MIT Press. 1996.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../setup/" class="btn btn-neutral float-left" title="Setup" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../compilers/" class="btn btn-neutral float-right" title="Compilers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>